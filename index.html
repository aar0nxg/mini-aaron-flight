<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>Mini Aaron: Flight to Zarifa</title>
<style>
  :root{--bg-1:#0f0620;--bg-2:#1b0a38;--accent:#ff5a7a;--accent-2:#b084ff;}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg-1),var(--bg-2));color:#fff;font-family:system-ui;}
  #gameRoot{position:relative;max-width:960px;margin:0 auto;height:100vh;overflow:hidden;}
  canvas{display:block;width:100%;height:100%}
  .hud{position:absolute;top:12px;left:12px;display:flex;gap:10px;z-index:5}
  .pill{background:rgba(0,0,0,.35);padding:8px 12px;border-radius:999px}
  .hud-right{position:absolute;top:12px;right:12px;display:flex;gap:10px;z-index:6}
  .bar{--p:0;position:relative;height:10px;width:200px;border-radius:999px;background:rgba(255,255,255,.15);overflow:hidden}
  .bar::after{content:"";position:absolute;inset:0;width:calc(var(--p)*1%);background:linear-gradient(90deg,var(--accent),var(--accent-2))}
  .rec{position:absolute;top:14px;right:14px;color:#ff4d4d;font-weight:800;text-shadow:0 0 10px #ff4d4d80}
  .rec::before{content:"‚óè "; }
  .overlay{position:absolute;inset:0;display:grid;place-items:center;background:rgba(10,0,20,.8);z-index:10;transition:opacity .3s}
  .overlay.hidden{opacity:0;pointer-events:none}
  .card{background:rgba(255,255,255,.06);padding:28px;border-radius:16px;text-align:center}
  .action{border:none;padding:12px 18px;border-radius:12px;font-weight:800;cursor:pointer;background:linear-gradient(180deg,var(--accent),#ff87a0);color:#fff}
  /* onscreen helper button (for trackpad hold) */
  .holdZone{position:absolute;bottom:18px;left:50%;transform:translateX(-50%);z-index:7;
            background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.2);backdrop-filter:blur(6px);
            padding:10px 16px;border-radius:999px;user-select:none}
</style>
</head>
<body>
<div id="gameRoot">
  <canvas id="game" tabindex="0"></canvas>

  <div class="hud">
    <div class="pill">‚ù§Ô∏è <span id="lives">x3</span></div>
    <div class="pill">‚úàÔ∏è Dist: <span id="km">10,000</span></div>
    <div class="pill bar" id="progress"></div>
  </div>
  <div class="hud-right">
    <div class="pill btn" id="pauseBtn">‚è∏Ô∏è</div>
    <div class="pill btn" id="muteBtn">üîä</div>
  </div>
  <div class="rec">REC</div>

  <div class="holdZone" id="holdZone">Hold here (or anywhere) to fly ‚Üë ¬∑ Space / ‚Üë / W also work</div>

  <!-- Start screen -->
  <div class="overlay" id="start">
    <div class="card">
      <h1>The Flight to Zarifa ‚úàÔ∏èüíú</h1>
      <p>MacBook friendly: <b>hold trackpad</b> anywhere to go up ‚Ä¢ or hold <b>Space / ‚Üë / W</b>.</p>
      <button class="action" id="playBtn">üé¨ Fly!</button>
    </div>
  </div>

  <!-- End screen -->
  <div class="overlay hidden" id="end">
    <div class="card">
      <h2>Mini Aaron & Zarifa Hug üíñ</h2>
      <button class="action" id="replayBtn">‚Üª Play again</button>
    </div>
  </div>
</div>

<script>
(() => {
  const cfg = {width:960,height:540,gravity:1400,thrust:2400,maxVy:800,baseSpeed:300,targetKm:10000,lives:3};
  const state = {dpr:Math.min(2,window.devicePixelRatio||1),playing:false,paused:false,t:0,dt:0,dist:0,lives:cfg.lives,ended:false};

  const root = document.getElementById('gameRoot');
  const canvas = document.getElementById('game'); const ctx = canvas.getContext('2d');
  function resize(){canvas.width=canvas.clientWidth*state.dpr;canvas.height=canvas.clientHeight*state.dpr;ctx.setTransform(state.dpr,0,0,state.dpr,0,0);}
  new ResizeObserver(resize).observe(root); resize();

  const elLives=document.getElementById('lives'), elKm=document.getElementById('km'), elProg=document.getElementById('progress');
  const elStart=document.getElementById('start'), elEnd=document.getElementById('end');
  const playBtn=document.getElementById('playBtn'), replayBtn=document.getElementById('replayBtn');
  const pauseBtn=document.getElementById('pauseBtn'), muteBtn=document.getElementById('muteBtn');
  const holdZone=document.getElementById('holdZone');

  /* ========= INPUT (MacBook-proof) ========= */
  let pressing = false;

  function isFlyKey(e){
    const c = e.code, k = e.key;
    return c==="Space"||c==="Spacebar"||c==="ArrowUp"||c==="KeyW"||k===" "||k==="w"||k==="W";
  }
  function down(e){
    if(isFlyKey(e)){ pressing=true; e.preventDefault(); }
    if(e.code==="KeyP") togglePause();
    if(e.code==="KeyM") toggleMute();
  }
  function up(e){
    if(isFlyKey(e)){ pressing=false; e.preventDefault(); }
  }

  // listen at window level, capture phase; include keypress to catch Safari space quirks
  window.addEventListener('keydown', down, true);
  window.addEventListener('keyup', up, true);
  window.addEventListener('keypress', (e)=>{ if(isFlyKey(e)) e.preventDefault(); }, true);

  // pointer (trackpad/mouse) anywhere on the game
  const pressStart=()=>{ pressing=true; };
  const pressEnd = ()=>{ pressing=false; };
  ['pointerdown','mousedown','touchstart'].forEach(t=> root.addEventListener(t, pressStart, {passive:false}));
  ['pointerup','pointercancel','pointerleave','mouseup','touchend'].forEach(t=> root.addEventListener(t, pressEnd, {passive:false}));

  /* ========= PLANE ========= */
  class Plane{
    constructor(){ this.x=160; this.y=cfg.height*0.6; this.vy=0; this.w=68; this.h=28; }
    update(dt){
      const accel = cfg.gravity - (pressing ? cfg.thrust : 0); // press = go up
      this.vy += accel * dt;
      this.vy = Math.max(-cfg.maxVy, Math.min(cfg.maxVy, this.vy));
      this.y  += this.vy * dt;
      if(this.y<30){ this.y=30; this.vy=0; }
      if(this.y>cfg.height-30){ this.y=cfg.height-30; this.vy=0; }
    }
    draw(ctx){
      ctx.save(); ctx.translate(this.x,this.y);
      // simple visible block (swap for your fancy plane later)
      ctx.fillStyle='#e5e2ff'; ctx.fillRect(-this.w/2,-this.h/2,this.w,this.h);
      ctx.restore();
    }
  }
  const plane = new Plane();

  function updateHUD(){
    elLives.textContent = `x${state.lives}`;
    elKm.textContent = (cfg.targetKm - Math.floor(state.dist)).toLocaleString();
    elProg.style.setProperty('--p', (state.dist/cfg.targetKm*100).toFixed(2));
  }

  /* ========= LOOP ========= */
  let last=performance.now();
  function loop(now){
    const dt=Math.min(0.033,(now-last)/1000); last=now;
    if(state.paused||!state.playing){ requestAnimationFrame(loop); return; }
    state.t+=dt;
    plane.update(dt);
    state.dist = Math.min(cfg.targetKm, state.dist + (cfg.baseSpeed/3.5)*dt);
    ctx.fillStyle='#120a1d'; ctx.fillRect(0,0,cfg.width,cfg.height);
    plane.draw(ctx);
    updateHUD();
    if(state.dist>=cfg.targetKm && !state.ended){ state.ended=true; endGame(true); }
    requestAnimationFrame(loop);
  }

  /* ========= CONTROL ========= */
  function startGame(){
    state.playing=true; state.paused=false; state.t=0; state.dist=0; state.lives=cfg.lives; state.ended=false;
    elStart.classList.add('hidden'); elEnd.classList.add('hidden');
    window.focus(); canvas.focus();
    requestAnimationFrame(n=>{ last=n; requestAnimationFrame(loop); });
  }
  function endGame(won){
    state.playing=false;
    if(won){ elEnd.classList.remove('hidden'); } else { elStart.classList.remove('hidden'); }
  }
  function togglePause(){ if(!state.playing) return; state.paused=!state.paused; pauseBtn.textContent=state.paused?'‚ñ∂Ô∏è':'‚è∏Ô∏è'; }
  function toggleMute(){ muteBtn.textContent = (muteBtn.textContent==='üîä'?'üîá':'üîä'); }

  playBtn.onclick = startGame;
  replayBtn.onclick = ()=>{ elEnd.classList.add('hidden'); startGame(); };

  // safety: if the tab loses focus, stop ascending
  window.addEventListener('blur', ()=> pressing=false);
  document.addEventListener('visibilitychange', ()=>{ if(document.hidden) pressing=false; });

  updateHUD();
})();
</script>
</body>
</html>
